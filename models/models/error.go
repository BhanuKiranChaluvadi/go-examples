// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Error error model
//
// swagger:model Error
type Error struct {

	// Error codes.This field contains a string succinctly identifying     the problem.
	//
	// Example: missing_field
	// Enum: [success unknown internal_error invalid_file_extension invalid_file invalid_path not_found cannot_read zip_corrupted unzip_failed metadata_mismatch metadata_error metadata_yaml_syntax_error metadata_invalid unsupported_artifact_type missing_artifact invalid_artifact over_sized_artifact already_installed installation_failed already_started start_failed missing_field]
	Code string `json:"code,omitempty" yaml:"code,omitempty"`

	// This field contain a plainly-written, developer-oriented explanation of the solution to the problem in complete, well-formed sentences.
	// Example: The `first_name` field is required.
	Message string `json:"message,omitempty" yaml:"message,omitempty"`

	// This field SHOULD contain a publicly-accessible URL where information about the error can be read in a web browser.
	// Example: https://docs.api.example.com/v2/users/create_user#first_name
	MoreInfo string `json:"more_info,omitempty" yaml:"more_info,omitempty"`

	// target
	Target *ErrorTarget `json:"target,omitempty" yaml:"target,omitempty"`
}

// UnmarshalJSON unmarshals this object while disallowing additional properties from JSON
func (m *Error) UnmarshalJSON(data []byte) error {
	var props struct {

		// Error codes.This field contains a string succinctly identifying     the problem.
		//
		// Example: missing_field
		// Enum: [success unknown internal_error invalid_file_extension invalid_file invalid_path not_found cannot_read zip_corrupted unzip_failed metadata_mismatch metadata_error metadata_yaml_syntax_error metadata_invalid unsupported_artifact_type missing_artifact invalid_artifact over_sized_artifact already_installed installation_failed already_started start_failed missing_field]
		Code string `json:"code,omitempty" yaml:"code,omitempty"`

		// This field contain a plainly-written, developer-oriented explanation of the solution to the problem in complete, well-formed sentences.
		// Example: The `first_name` field is required.
		Message string `json:"message,omitempty" yaml:"message,omitempty"`

		// This field SHOULD contain a publicly-accessible URL where information about the error can be read in a web browser.
		// Example: https://docs.api.example.com/v2/users/create_user#first_name
		MoreInfo string `json:"more_info,omitempty" yaml:"more_info,omitempty"`

		// target
		Target *ErrorTarget `json:"target,omitempty" yaml:"target,omitempty"`
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.DisallowUnknownFields()
	if err := dec.Decode(&props); err != nil {
		return err
	}

	m.Code = props.Code
	m.Message = props.Message
	m.MoreInfo = props.MoreInfo
	m.Target = props.Target
	return nil
}

// Validate validates this error
func (m *Error) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var errorTypeCodePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["success","unknown","internal_error","invalid_file_extension","invalid_file","invalid_path","not_found","cannot_read","zip_corrupted","unzip_failed","metadata_mismatch","metadata_error","metadata_yaml_syntax_error","metadata_invalid","unsupported_artifact_type","missing_artifact","invalid_artifact","over_sized_artifact","already_installed","installation_failed","already_started","start_failed","missing_field"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		errorTypeCodePropEnum = append(errorTypeCodePropEnum, v)
	}
}

const (

	// ErrorCodeSuccess captures enum value "success"
	ErrorCodeSuccess string = "success"

	// ErrorCodeUnknown captures enum value "unknown"
	ErrorCodeUnknown string = "unknown"

	// ErrorCodeInternalError captures enum value "internal_error"
	ErrorCodeInternalError string = "internal_error"

	// ErrorCodeInvalidFileExtension captures enum value "invalid_file_extension"
	ErrorCodeInvalidFileExtension string = "invalid_file_extension"

	// ErrorCodeInvalidFile captures enum value "invalid_file"
	ErrorCodeInvalidFile string = "invalid_file"

	// ErrorCodeInvalidPath captures enum value "invalid_path"
	ErrorCodeInvalidPath string = "invalid_path"

	// ErrorCodeNotFound captures enum value "not_found"
	ErrorCodeNotFound string = "not_found"

	// ErrorCodeCannotRead captures enum value "cannot_read"
	ErrorCodeCannotRead string = "cannot_read"

	// ErrorCodeZipCorrupted captures enum value "zip_corrupted"
	ErrorCodeZipCorrupted string = "zip_corrupted"

	// ErrorCodeUnzipFailed captures enum value "unzip_failed"
	ErrorCodeUnzipFailed string = "unzip_failed"

	// ErrorCodeMetadataMismatch captures enum value "metadata_mismatch"
	ErrorCodeMetadataMismatch string = "metadata_mismatch"

	// ErrorCodeMetadataError captures enum value "metadata_error"
	ErrorCodeMetadataError string = "metadata_error"

	// ErrorCodeMetadataYamlSyntaxError captures enum value "metadata_yaml_syntax_error"
	ErrorCodeMetadataYamlSyntaxError string = "metadata_yaml_syntax_error"

	// ErrorCodeMetadataInvalid captures enum value "metadata_invalid"
	ErrorCodeMetadataInvalid string = "metadata_invalid"

	// ErrorCodeUnsupportedArtifactType captures enum value "unsupported_artifact_type"
	ErrorCodeUnsupportedArtifactType string = "unsupported_artifact_type"

	// ErrorCodeMissingArtifact captures enum value "missing_artifact"
	ErrorCodeMissingArtifact string = "missing_artifact"

	// ErrorCodeInvalidArtifact captures enum value "invalid_artifact"
	ErrorCodeInvalidArtifact string = "invalid_artifact"

	// ErrorCodeOverSizedArtifact captures enum value "over_sized_artifact"
	ErrorCodeOverSizedArtifact string = "over_sized_artifact"

	// ErrorCodeAlreadyInstalled captures enum value "already_installed"
	ErrorCodeAlreadyInstalled string = "already_installed"

	// ErrorCodeInstallationFailed captures enum value "installation_failed"
	ErrorCodeInstallationFailed string = "installation_failed"

	// ErrorCodeAlreadyStarted captures enum value "already_started"
	ErrorCodeAlreadyStarted string = "already_started"

	// ErrorCodeStartFailed captures enum value "start_failed"
	ErrorCodeStartFailed string = "start_failed"

	// ErrorCodeMissingField captures enum value "missing_field"
	ErrorCodeMissingField string = "missing_field"
)

// prop value enum
func (m *Error) validateCodeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, errorTypeCodePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Error) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(m.Code) { // not required
		return nil
	}

	// value enum
	if err := m.validateCodeEnum("code", "body", m.Code); err != nil {
		return err
	}

	return nil
}

func (m *Error) validateTarget(formats strfmt.Registry) error {
	if swag.IsZero(m.Target) { // not required
		return nil
	}

	if m.Target != nil {
		if err := m.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this error based on the context it is used
func (m *Error) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Error) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if m.Target != nil {
		if err := m.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Error) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Error) UnmarshalBinary(b []byte) error {
	var res Error
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
